diff --git a/drivers/of/device.c b/drivers/of/device.c
index 8cefe5a..e29646d 100644
--- a/drivers/of/device.c
+++ b/drivers/of/device.c
@@ -240,11 +240,40 @@ const void *of_device_get_match_data(const struct device *dev)
 {
 	const struct of_device_id *match;
 
+#define STR_PROTECT(X) X ? X : "NULL"
+	bool debug = dev->driver->of_match_table && \
+							dev->driver->of_match_table->compatible && \
+							dev->driver->of_match_table->compatible[0] == 'd' && \
+							dev->driver->of_match_table->compatible[1] == 'e' && \
+							dev->driver->of_match_table->compatible[2] == 'b' && \
+							dev->driver->of_match_table->compatible[3] == 'u' && \
+							dev->driver->of_match_table->compatible[4] == 'g';
+
 	match = of_match_device(dev->driver->of_match_table, dev);
+	if (debug){
+			printk("match for %s %s found\n",
+						dev->of_node ? STR_PROTECT(dev->of_node->full_name) : "none",
+						match ? "\b" : "not");
+	}
 	if (!match)
 		return NULL;
 
+	if (debug){
+			struct property *compat = of_get_property(dev->of_node, "compatible", NULL);
+			if (compat->value){
+				printk("of_node %s tested with: %p\n",
+							dev->of_node ? STR_PROTECT(dev->of_node->full_name) : "none",
+							compat->value);
+			}
+			else {
+				printk("'compatible' property for %s is null or zero-length\n",
+							dev->of_node ? STR_PROTECT(dev->of_node->full_name) : "none");
+			}
+	}
+
+
 	return match->data;
+#undef STR_PROTECT
 }
 EXPORT_SYMBOL(of_device_get_match_data);
 
